#include <iostream>
#include <math.h>
#include <cmath>

#define f(x) 1 / (1 + x * x)

using namespace std;

double DirectRectangleSum(double a, double b, int n, double& h)
{
	double x;
	double sum = 0.0;
	double fx;
	h = (b - a) / n;

	for (int i = 0; i < n; i++) 
	{
		x = a + i * h;
		fx = f(x);
		sum += fx;
	}
	return sum * h;
}

double DoDirectRectangle(double a, double b, double eps, int n, double& h, double& k)
{
	double s1, s;
	n = 1;
	s1 = DirectRectangleSum(a, b, n, h);
	do
	{
		s = s1;
		n = 2 * n;
		s1 = DirectRectangleSum(a, b, n, h);

	} while (fabs(s1 - s) > eps);
	k = (pow(s1, h / 2) - pow(s1, h)) / 3;
	return s1;
}

/////////////////////////////////////////////////////////////////////////

double Simpson38IntegralSum(double a, double b, int n, double& h)
{
	h = (b - a) / n;
	double sum = f(a) + f(b), x;
	for (int i = 1; i < n; i++)
	{
		x = a + i * h;
		if (i % 3 == 0)
			sum += 2 * f(x);
		else
			sum = sum + 3 * f(x);
	}

	return sum * ((3 * h) / 8);
}

double DoSimpson38Integral(double a, double b, double eps, int n, double& h, double& k)
{
	double s1, s;
	s1 = Simpson38IntegralSum(a, b, n, h);
	do {
		s = s1;
		n *= 3;
		s1 = Simpson38IntegralSum(a, b, n, h);
	} while (fabs(s1 - s) > eps);
	k = (pow(s1, h / 2) - pow(s1, h)) / 15;
	return s1;
}

/////////////////////////////////////////////////////////////////////////

double SimpsonIntegralSum(double a, double b, int n, double& h)
{
	h = (b - a) / n;
	double k1 = 0, k2 = 0, s1 = 0, s2 = 0, x1, x2;
	for (int i = 1; i < n; i += 2) {
		x1 = a + i * h;
		x2 = a + (i + 1) * h;
		k1 += f(x1);
		k2 += f(x2);
	}
	k2 = (h / 3) * (f(a) + 4 * k1 + 2 * k2);
	return k2;
}

double DoSimpsonIntegral(double a, double b, double eps, int n, double &h, double& k)
{
	double s1, s;
	s1 = SimpsonIntegralSum(a, b, n, h);
	do {
		s = s1;
		n = 2 * n;
		s1 = SimpsonIntegralSum(a, b, n, h);
	} while (fabs(s1 - s) > eps);
	k = (pow(s1, h / 2) - pow(s1, h)) / 15;
	return s1;
}

/////////////////////////////////////////////////////////////////////////

double TrapezeIntegralSum(double a, double b, int n, double& h)
{
	h = (b - a) / n;
	double x = 0, sum = 0.0;
	for (int i = 1; i < n; i++) {
		x = a + i * h;
		sum += f(x);
	}
	return (h / 2) * (f(a) + f(b) + 2 * sum);
}

double DoTrapezeIntegral(double a, double b, double eps, int n, double& h, double& k)
{
	double s1, s;
	s1 = TrapezeIntegralSum(a, b, n, h);
	do {
		s = s1;
		n++;
		s1 = TrapezeIntegralSum(a, b, n, h);
	} while (fabs(s1 - s) > eps);
	k = (pow(s1, h / 2) - pow(s1, h)) / 3;
	return s1;
}

/////////////////////////////////////////////////////////////////////////

int main() 
{
	double a, b, eps, h = 0, k = 0;
	int n = 1;
	cout << "Set the lower edge of integration a: ";
	cin >> a;
	cout << "Set the upper edge of integration b: ";
	cin >> b;
	cout << "Set preferred precision eps: ";
	cin >> eps;
	cout << "\nDirect rectangle's method: " << DoDirectRectangle(a, b, eps, n, h, k);
	cout << "\tPrecision: " << k << "\tStep size: " << h << endl;
	cout << "\nSimpson's method: " << DoSimpsonIntegral(a, b, eps, n, h, k) << "\tPrecision: " << k << "\tStep size: " << h << endl;
	cout << "\nSimpson3/8's method: " << DoSimpson38Integral(a, b, eps, n, h, k) << "\tPrecision: " << k << "\tStep size: " << h << endl;
	cout << "\nTrapeze's method: " << DoTrapezeIntegral(a, b, eps, n, h, k) << "\tPrecision: " << k << "\tStep size: " << h << endl;
}
